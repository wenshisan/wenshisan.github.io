<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">

















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: true,
    fastclick: true,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="AI,人工智能,Julia中文文档，Julia编程语言">
<meta name="keywords" content="AI,人工智能,Julia中文文档，Julia编程语言">
<meta property="og:type" content="website">
<meta property="og:title" content="醍醐果冻">
<meta property="og:url" content="http://www.thgd.net/index.html">
<meta property="og:site_name" content="醍醐果冻">
<meta property="og:description" content="AI,人工智能,Julia中文文档，Julia编程语言">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="醍醐果冻">
<meta name="twitter:description" content="AI,人工智能,Julia中文文档，Julia编程语言">






  <link rel="canonical" href="http://www.thgd.net/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>醍醐果冻</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">醍醐果冻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.thgd.net/2019/02/28/Variables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="醍醐果冻">
      <meta itemprop="description" content="AI,人工智能,Julia中文文档，Julia编程语言">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醍醐果冻">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/Variables/" class="post-title-link" itemprop="url">变量</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-28 17:37:37" itemprop="dateCreated datePublished" datetime="2019-02-28T17:37:37+08:00">2019-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-04 09:39:14" itemprop="dateModified" datetime="2019-03-04T09:39:14+08:00">2019-03-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/" itemprop="url" rel="index"><span itemprop="name">Julia中文文档</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/手册/" itemprop="url" rel="index"><span itemprop="name">手册</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/手册/变量/" itemprop="url" rel="index"><span itemprop="name">变量</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>&emsp;在Julia中，变量是一个对应（或绑定）到一个值的名称。这对您想要储存一个值以备后用（比如您从某些数学计算中得到的值）来说很有帮助。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Assign the value 10 to the variable x</span></span><br><span class="line">julia&gt; x = 10</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Doing math with x's value</span></span><br><span class="line">julia&gt; x + 1</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reassign x's value</span></span><br><span class="line">julia&gt; x = 1 + 1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can assign values of other types, like strings of text</span></span><br><span class="line">julia&gt; x = <span class="string">"Hello World!"</span></span><br><span class="line"><span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;Julia 为变量的命名提供了一个极其灵活的系统。 变量名是区分大小写且没有语义上的意义（是的，语言不会因为他们的名字而进行区别对待）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = 1.0</span><br><span class="line">1.0</span><br><span class="line"></span><br><span class="line">julia&gt; y = -3</span><br><span class="line">-3</span><br><span class="line"></span><br><span class="line">julia&gt; Z = <span class="string">"My string"</span></span><br><span class="line"><span class="string">"My string"</span></span><br><span class="line"></span><br><span class="line">julia&gt; customary_phrase = <span class="string">"Hello world!"</span></span><br><span class="line"><span class="string">"Hello world!"</span></span><br><span class="line"></span><br><span class="line">julia&gt; UniversalDeclarationOfHumanRightsStart = <span class="string">"人人生而自由，在尊严和权利上一律平等。"</span></span><br><span class="line"><span class="string">"人人生而自由，在尊严和权利上一律平等。"</span></span><br><span class="line">Unicode names (<span class="keyword">in</span> UTF-8 encoding) are allowed:</span><br><span class="line"></span><br><span class="line">julia&gt; δ = 0.00001</span><br><span class="line">1.0e-5</span><br><span class="line"></span><br><span class="line">julia&gt; 안녕하세요 = <span class="string">"Hello"</span></span><br><span class="line"><span class="string">"Hello"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;在Julia的REPL和其他一些Julia编辑环境中，您可以通过输入反斜杠 LaTeX 符号跟着 <code>tab</code> 输入很多Unicode数学符号。例如，变量名 <code>δ</code> 可以通过输入 <code>\delta-tab</code> 键入，<code>α̂₂</code> 通过 <code>\alpha-tab-\hat- tab-\_2-tab</code> 。（如果你在某个例如其他人的代码里找到了您不知道如何输入的符号，REPL帮助将会告诉您：只需输入 <code>?</code> 然后粘贴这个符号）。</p>
<p>&emsp;如果需要的话Julia将也允许您重新定义内置的常量和函数（然而为避免潜在的混淆并不推荐您这么做）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; pi = 3</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">julia&gt; pi</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">julia&gt; sqrt = 4</span><br><span class="line">4</span><br><span class="line">However, <span class="keyword">if</span> you try to redefine a built-in constant or <span class="keyword">function</span> already <span class="keyword">in</span> use, Julia will give you an error:</span><br><span class="line"></span><br><span class="line">julia&gt; pi</span><br><span class="line">π = 3.1415926535897...</span><br><span class="line"></span><br><span class="line">julia&gt; pi = 3</span><br><span class="line">ERROR: cannot assign variable MathConstants.pi from module Main</span><br><span class="line"></span><br><span class="line">julia&gt; sqrt(100)</span><br><span class="line">10.0</span><br><span class="line"></span><br><span class="line">julia&gt; sqrt = 4</span><br><span class="line">ERROR: cannot assign variable Base.sqrt from module Main</span><br></pre></td></tr></table></figure>
<h3 id="允许的变量名"><a href="#允许的变量名" class="headerlink" title="允许的变量名"></a>允许的变量名</h3><p>&emsp;变量名必须以字母开头（<code>A-Z</code> 或 <code>a-z</code>），下划线，或者大于00A0的 Unicode 代码标点集合，尤其是 Unicode 字符分类 <code>Lu/Ll/Lt/Lm/Lo/Nl</code>（字母），<code>Sc/So</code>（货币和其他符号），还有其他一些类似字母的字符（例如 Sm 数学符号的集合）都被允许使用。随后的字符也可能包括 <code>!</code> 和数字（0-9和其他分类的字符 <code>Nd/No</code>），同时其他的Unicode代码标点：区分标识和其他标识符（<code>Mn/Mc/Me/Sk</code>分类），一些连接字符（<code>Pc</code> 分类）,上撇号，还有一些其他的字符。</p>
<p>&emsp;类似+的运算符也都是有效的标识符，但被特殊的格式化了。在一些上下文中，运算符也可以像变量一样使用，例如<code>(+)</code>指的是加法函数，<code>(+) = f</code>将会把它重新赋值。多数的Unicode中缀运算符（在 <code>Sm</code> 分类中）,如<code>⊕</code>，都被格式化为中缀运算符并可用于用户定义的的方法（例如您可以使用 <code>const ⊗ = kron</code> 来定义<code>⊗</code>为一个中缀克罗内克积（Koronecker）乘积）。运算符也可以用修饰符、上撇号和上/下标作为后缀，例如<code>+̂ₐ″</code> 被格式化为以+号开头的中缀运算符。</p>
<p>&emsp;仅内置语句的名称明确的不能作为变量使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">else</span> = <span class="literal">false</span></span><br><span class="line">ERROR: syntax: unexpected <span class="string">"else"</span></span><br><span class="line"></span><br><span class="line">julia&gt; try = <span class="string">"No"</span></span><br><span class="line">ERROR: syntax: unexpected <span class="string">"="</span></span><br></pre></td></tr></table></figure>
<p>&emsp;一些Unicode字符被视为等同于标识符。Unicode组合字符的不同输入方式（例如 <code>,</code> 强调）都被视为相同（Julia标识都是特别的、NPC-标准化的）。Unicode字符<code>ɛ</code>(<code>U+025B</code>:小写拉丁字母 e)和<code>µ</code>（<code>U+00B5</code>: 读谬miu，英文micro sign）都被视为等于对应的希腊字母，因为前者更容易使用输入法输入。</p>
<h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><p>Julia在有效命名上做了少量限制规则，以变得有益于接下来的类型转换：</p>
<ul>
<li>变量名都小写。</li>
<li>可以使用下划线（<code>&#39;_&#39;</code>）标出单词分隔,但是除非名称难以阅读否则不建议使用下划线。</li>
<li>类型和模块的名称的开头以及单词分隔使用首字母大写的驼峰形式代替下划线。</li>
<li>函数和宏命令的名称为小谢形式，没有下划线。</li>
<li>参数名以<code>!</code>结尾的函数。有时被称之为 “变异” 或 “原位” 函数，因为他们在被调用后会改变他们的参数，不只是返回值。</li>
<li>更新格式转换的信息，查看<a href="https://docs.julialang.org/en/v1/manual/style-guide/#Style-Guide-1" target="_blank" rel="noopener">格式指南</a>。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.thgd.net/2019/02/28/IntegersAndFloat-PointNumbers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="醍醐果冻">
      <meta itemprop="description" content="AI,人工智能,Julia中文文档，Julia编程语言">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醍醐果冻">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/IntegersAndFloat-PointNumbers/" class="post-title-link" itemprop="url">整数和浮点数</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-28 17:37:37" itemprop="dateCreated datePublished" datetime="2019-02-28T17:37:37+08:00">2019-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-05 12:03:12" itemprop="dateModified" datetime="2019-03-05T12:03:12+08:00">2019-03-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/" itemprop="url" rel="index"><span itemprop="name">Julia中文文档</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/手册/" itemprop="url" rel="index"><span itemprop="name">手册</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/手册/整数和浮点数/" itemprop="url" rel="index"><span itemprop="name">整数和浮点数</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h3><hr>
<p>&emsp;整数和浮点数是算法和计算的基础构件。尽管整数和浮点数直接值的表示在代码中被看作是数字字符，一些内置值的表示则被称之为数值类型。例如虽然 <code>1.0</code> 是一个浮点数字符， <code>1</code> 是一个整数字符，他们在内存中的二进制对象都是数值类型。</p>
<p>&emsp;Julia 提供了一个范围广泛的基础数字类型并且在他们之上定义了标准数学函数还有完整的算法和按位运算的补集。这些直接在数字类型和运算上的映射都原生地被现代计算机所支持，因此让 Julia 可以最大限度的利用计算资源。此外 Julia 提供了可以控制无法有效地在原本的硬件中表示的数值计算的高精度计算的软件支持，但会导致较低性能。</p>
<p>下列内容为 Julia 的基础数字类型：</p>
<ul>
<li>整数类型：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">有符号?</th>
<th style="text-align:center">位数</th>
<th style="text-align:center">最小值</th>
<th style="text-align:center">最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Int8</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-2^7</td>
<td style="text-align:center">2^7 - 1</td>
</tr>
<tr>
<td style="text-align:center">UInt8</td>
<td style="text-align:center"></td>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2^8 - 1</td>
</tr>
<tr>
<td style="text-align:center">Int16</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">16</td>
<td style="text-align:center">-2^15</td>
<td style="text-align:center">2^15 - 1</td>
</tr>
<tr>
<td style="text-align:center">UInt16</td>
<td style="text-align:center"></td>
<td style="text-align:center">16</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2^16 - 1</td>
</tr>
<tr>
<td style="text-align:center">Int32</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">32</td>
<td style="text-align:center">-2^31</td>
<td style="text-align:center">2^31 - 1</td>
</tr>
<tr>
<td style="text-align:center">UInt32</td>
<td style="text-align:center"></td>
<td style="text-align:center">32</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2^32 - 1</td>
</tr>
<tr>
<td style="text-align:center">Int64</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">64</td>
<td style="text-align:center">-2^63</td>
<td style="text-align:center">2^63 - 1</td>
</tr>
<tr>
<td style="text-align:center">UInt64</td>
<td style="text-align:center"></td>
<td style="text-align:center">64</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2^64 - 1</td>
</tr>
<tr>
<td style="text-align:center">Int128</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">128</td>
<td style="text-align:center">-2^127</td>
<td style="text-align:center">2^127 - 1</td>
</tr>
<tr>
<td style="text-align:center">UInt128</td>
<td style="text-align:center"></td>
<td style="text-align:center">128</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2^128 - 1</td>
</tr>
<tr>
<td style="text-align:center">Bool</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">8</td>
<td style="text-align:center">false (0)</td>
<td style="text-align:center">true (1)</td>
</tr>
</tbody>
</table>
<ul>
<li>浮点类型：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">精度</th>
<th style="text-align:center">位数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Float16</td>
<td style="text-align:center">半精度</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center">Float32</td>
<td style="text-align:center">单精度</td>
<td style="text-align:center">32</td>
</tr>
<tr>
<td style="text-align:center">Float64</td>
<td style="text-align:center">双精度</td>
<td style="text-align:center">64</td>
</tr>
</tbody>
</table>
<p>此外，复数和有理数的完全支持是建立在这些基础数字类型上的。所有数字类型不用刻意分配即可自然交互，感谢灵活的、用户可扩展的类型提升系统。</p>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>整数字面上以正常形式表示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; 1</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">julia&gt; 1234</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<p>整数字符的默认类型取决于目标系统是 32 位架构或 64 位架构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32-bit system:</span></span><br><span class="line">julia&gt; typeof(1)</span><br><span class="line">Int32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit system:</span></span><br><span class="line">julia&gt; typeof(1)</span><br><span class="line">Int64</span><br></pre></td></tr></table></figure>
<p>Julia 内置的变量 <code>Sys.WORD_SIZE</code> 标示出目标系统是 <code>32</code> 位或 <code>64</code> 位：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32-bit system:</span></span><br><span class="line">julia&gt; Sys.WORD_SIZE</span><br><span class="line">32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit system:</span></span><br><span class="line">julia&gt; Sys.WORD_SIZE</span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<p>Julia 也分别规定了系统的有符号和无符号整数类型的别名类型 <code>Int</code> 和 <code>UInt</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32-bit system:</span></span><br><span class="line">julia&gt; Int</span><br><span class="line">Int32</span><br><span class="line">julia&gt; UInt</span><br><span class="line">UInt32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit system:</span></span><br><span class="line">julia&gt; Int</span><br><span class="line">Int64</span><br><span class="line">julia&gt; UInt</span><br><span class="line">UInt64</span><br></pre></td></tr></table></figure>
<p>不论系统类型是什么，较大的整数字符不止能使用 32 位表示，而且还可以以 64 位表示并创建 64 位整数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32-bit or 64-bit system:</span></span><br><span class="line">julia&gt; typeof(3000000000)</span><br><span class="line">Int64</span><br></pre></td></tr></table></figure>
<p>无符号整数可以使用前缀 <code>0x</code> 和十六进制（基数为 <code>16</code>）的数字 <code>0-9a-f</code> （以数字 <code>A-F</code> 在输入中同样有效）输入和输出。无符号值的大小取决于所使用的十六进制数字的数量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; 0x1</span><br><span class="line">0x01</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">UInt8</span><br><span class="line"></span><br><span class="line">julia&gt; 0x123</span><br><span class="line">0x0123</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">UInt16</span><br><span class="line"></span><br><span class="line">julia&gt; 0x1234567</span><br><span class="line">0x01234567</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">UInt32</span><br><span class="line"></span><br><span class="line">julia&gt; 0x123456789abcdef</span><br><span class="line">0x0123456789abcdef</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">UInt64</span><br><span class="line"></span><br><span class="line">julia&gt; 0x11112222333344445555666677778888</span><br><span class="line">0x11112222333344445555666677778888</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">UInt128</span><br></pre></td></tr></table></figure>
<p>这个行为基于当为整数值使用无符号十六进制字符时的观察，典型是使用他们代表一个固定的数字字节序列，而不只是一个整数值。</p>
<p>回调变量 <code>ans</code> 是最后一个可交互表达式计算后的值。这个不会出现在以其他方式运行的 Julia 代码中。</p>
<p>同样支持二进制和八进制字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; 0b10</span><br><span class="line">0x02</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">UInt8</span><br><span class="line"></span><br><span class="line">julia&gt; 0o010</span><br><span class="line">0x08</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">UInt8</span><br><span class="line"></span><br><span class="line">julia&gt; 0x00000000000000001111222233334444</span><br><span class="line">0x00000000000000001111222233334444</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">UInt128</span><br></pre></td></tr></table></figure>
<p>至于十六进制字符，二进制和八进制字符产生无符号整数类型。如果字符的首位数字不是0，二进制数据项的大小为最小必须大小。就首位为0的情况来说，大小取决于有着相同长度但首位为1的字符的最小大小。这允许用户控制那些不能存入 <code>UInt128</code> 不能被写成那种字符的值的大小。</p>
<p>二进制、八进制和十六进制字符可能被直接在无符号证书前直接加上 <code>-</code> 。 他们产生出一个带有和无符号大小相同的有符号整数和该值的两个整数的补集：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; -0x2</span><br><span class="line">0xfe</span><br><span class="line"></span><br><span class="line">julia&gt; -0x0002</span><br><span class="line">0xfffe</span><br></pre></td></tr></table></figure>
<p>如整数一样的基础数字类型可表示的最大和最小值可用使用 <code>typemin</code> 和 <code>typemax</code> 求出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; (typemin(Int32), typemax(Int32))</span><br><span class="line">(-2147483648, 2147483647)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> T <span class="keyword">in</span> [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]</span><br><span class="line">           println(<span class="string">"<span class="variable">$(lpad(T,7)</span>): [<span class="variable">$(typemin(T)</span>),<span class="variable">$(typemax(T)</span>)]"</span>)</span><br><span class="line">       end</span><br><span class="line">   Int8: [-128,127]</span><br><span class="line">  Int16: [-32768,32767]</span><br><span class="line">  Int32: [-2147483648,2147483647]</span><br><span class="line">  Int64: [-9223372036854775808,9223372036854775807]</span><br><span class="line"> Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]</span><br><span class="line">  UInt8: [0,255]</span><br><span class="line"> UInt16: [0,65535]</span><br><span class="line"> UInt32: [0,4294967295]</span><br><span class="line"> UInt64: [0,18446744073709551615]</span><br><span class="line">UInt128: [0,340282366920938463463374607431768211455]</span><br></pre></td></tr></table></figure>
<p><code>typemin</code> 和 <code>typemax</code> 的返回值总是给定的参数类型。（上面的表达式使用了一些还没有介绍的特性，包括 <code>for</code> 循环、 <code>String</code> 和互操作，但是对于已经有一些编程经验的用户来说已经足够容易理解了）。</p>
<h5 id="溢出行为"><a href="#溢出行为" class="headerlink" title="溢出行为"></a>溢出行为</h5><p>在Julia中，超过给定的类型的最大可表示值将导致包绕行为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = typemax(Int64)</span><br><span class="line">9223372036854775807</span><br><span class="line"></span><br><span class="line">julia&gt; x + 1</span><br><span class="line">-9223372036854775808</span><br><span class="line"></span><br><span class="line">julia&gt; x + 1 == typemin(Int64)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>&emsp;因此使用 Julia 的整数算法实际上是一种模数算法形式。这也反映出了现代计算机上的底层整数算法特征。在可能出现溢出的应用中明确地检查溢出所产生的包绕是十分必要的，否则推荐使用高精度计算来代替。</p>
<h5 id="除法错误"><a href="#除法错误" class="headerlink" title="除法错误"></a>除法错误</h5><p>&emsp;整数除法（ <code>div</code> 函数）有两种异常情况：用 <code>0</code> 除和用最小负整数（ <code>typemin</code> ） <code>-1</code> 除。这两种情形抛出一个 <code>DivideError</code>。<br>取余和取模函数（<code>rem</code> 和 <code>mod</code>）在他们的第二个参数为 <code>0</code> 时抛出 <code>DivideError</code>。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>字面上的浮点数字以正常的格式表示，如果需要会使用 <code>E</code> 符号来表示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; 1.0</span><br><span class="line">1.0</span><br><span class="line"></span><br><span class="line">julia&gt; 1.</span><br><span class="line">1.0</span><br><span class="line"></span><br><span class="line">julia&gt; 0.5</span><br><span class="line">0.5</span><br><span class="line"></span><br><span class="line">julia&gt; .5</span><br><span class="line">0.5</span><br><span class="line"></span><br><span class="line">julia&gt; -1.23</span><br><span class="line">-1.23</span><br><span class="line"></span><br><span class="line">julia&gt; 1e10</span><br><span class="line">1.0e10</span><br><span class="line"></span><br><span class="line">julia&gt; 2.5e-4</span><br><span class="line">0.00025</span><br></pre></td></tr></table></figure>
<p>以上的结果都是 <code>Float64</code> 数值。 字面上的 <code>Float32</code> 数值可以其中使用 <code>f</code> 代替 <code>e</code> 书写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; 0.5f0</span><br><span class="line">0.5f0</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">Float32</span><br><span class="line"></span><br><span class="line">julia&gt; 2.5f-4</span><br><span class="line">0.00025f0</span><br><span class="line">Values can be converted to Float32 easily:</span><br><span class="line"></span><br><span class="line">julia&gt; Float32(-1.5)</span><br><span class="line">-1.5f0</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">Float32</span><br></pre></td></tr></table></figure>
<p>十六进制的浮点字符同样有效，但仅以 <code>p</code> 在前 <code>2</code> 为基数的指数的 <code>Float64</code> 型数值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; 0x1p0</span><br><span class="line">1.0</span><br><span class="line"></span><br><span class="line">julia&gt; 0x1.8p3</span><br><span class="line">12.0</span><br><span class="line"></span><br><span class="line">julia&gt; 0x.4p-1</span><br><span class="line">0.125</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(ans)</span><br><span class="line">Float64</span><br></pre></td></tr></table></figure>
<p>同样也支持半精度浮点数（<code>Float16</code>），但是他们在软件中实现并使用 <code>Float32</code> 进行计算。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; sizeof(Float16(4.))</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">julia&gt; 2*Float16(4.)</span><br><span class="line">Float16(8.0)</span><br></pre></td></tr></table></figure>
<p>下划线 <code>_</code> 可以用作数字分割：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010</span><br><span class="line">(10000, 5.0e-9, 0xdeadbeef, 0xb2)</span><br></pre></td></tr></table></figure>
<h4 id="浮点0"><a href="#浮点0" class="headerlink" title="浮点0"></a>浮点0</h4><p>浮点数有两个 <code>0</code>, 正 <code>0</code> 和负 <code>0</code>。他们和对方相等但是却有着不同的二进制表示，例如使用 <code>bitstring</code> 观察：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; 0.0 == -0.0</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">julia&gt; bitstring(0.0)</span><br><span class="line"><span class="string">"0000000000000000000000000000000000000000000000000000000000000000"</span></span><br><span class="line"></span><br><span class="line">julia&gt; bitstring(-0.0)</span><br><span class="line"><span class="string">"1000000000000000000000000000000000000000000000000000000000000000"</span></span><br></pre></td></tr></table></figure>
<h4 id="特殊浮点数值"><a href="#特殊浮点数值" class="headerlink" title="特殊浮点数值"></a>特殊浮点数值</h4><p>这里有三个确定的标准浮点数值不对应实数线上的任何点：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Float16</th>
<th style="text-align:center">Float32</th>
<th style="text-align:center">Float64</th>
<th style="text-align:center">Name</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Inf16</td>
<td style="text-align:center">Inf32</td>
<td style="text-align:center">Inf</td>
<td style="text-align:center">正无穷</td>
<td style="text-align:center">一个大于所有有限浮点数的值</td>
</tr>
<tr>
<td style="text-align:center">-Inf16</td>
<td style="text-align:center">-Inf32</td>
<td style="text-align:center">-Inf</td>
<td style="text-align:center">负无穷</td>
<td style="text-align:center">一个小于所有有限浮点数的值</td>
</tr>
<tr>
<td style="text-align:center">NaN16</td>
<td style="text-align:center">NaN32</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">非数字类型</td>
<td style="text-align:center">一个不等于所有浮点数（包括它自身）值的值</td>
</tr>
</tbody>
</table>
<p>为了更深入的讨论这些无穷的浮点数值是怎样有序地涉及对方和其他浮点，查看数字比较。 通过 IEEE 754 标准，这些浮点数值是一些特定的算法运算的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; 1/Inf</span><br><span class="line">0.0</span><br><span class="line"></span><br><span class="line">julia&gt; 1/0</span><br><span class="line">Inf</span><br><span class="line"></span><br><span class="line">julia&gt; -5/0</span><br><span class="line">-Inf</span><br><span class="line"></span><br><span class="line">julia&gt; 0.000001/0</span><br><span class="line">Inf</span><br><span class="line"></span><br><span class="line">julia&gt; 0/0</span><br><span class="line">NaN</span><br><span class="line"></span><br><span class="line">julia&gt; 500 + Inf</span><br><span class="line">Inf</span><br><span class="line"></span><br><span class="line">julia&gt; 500 - Inf</span><br><span class="line">-Inf</span><br><span class="line"></span><br><span class="line">julia&gt; Inf + Inf</span><br><span class="line">Inf</span><br><span class="line"></span><br><span class="line">julia&gt; Inf - Inf</span><br><span class="line">NaN</span><br><span class="line"></span><br><span class="line">julia&gt; Inf * Inf</span><br><span class="line">Inf</span><br><span class="line"></span><br><span class="line">julia&gt; Inf / Inf</span><br><span class="line">NaN</span><br><span class="line"></span><br><span class="line">julia&gt; 0 * Inf</span><br><span class="line">NaN</span><br></pre></td></tr></table></figure>
<p><code>typemin</code> 和 <code>typemax</code> 也同样应用于浮点类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; (typemin(Float16),typemax(Float16))</span><br><span class="line">(-Inf16, Inf16)</span><br><span class="line"></span><br><span class="line">julia&gt; (typemin(Float32),typemax(Float32))</span><br><span class="line">(-Inf32, Inf32)</span><br><span class="line"></span><br><span class="line">julia&gt; (typemin(Float64),typemax(Float64))</span><br><span class="line">(-Inf, Inf)</span><br></pre></td></tr></table></figure>
<h4 id="机械极小值"><a href="#机械极小值" class="headerlink" title="机械极小值"></a>机械极小值</h4><p>多数实数不能完全地由浮点数表示，因此对于很目标来说知道相邻的两个可表示的浮点数之间的距离很重要，这通常被称之为机械极小值。</p>
<p>Julia 提供了机械极小值 <code>eps</code>，这给出了在 <code>1.0</code> 和下一个较大的可表示的浮点数值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; eps(Float32)</span><br><span class="line">1.1920929f-7</span><br><span class="line"></span><br><span class="line">julia&gt; eps(Float64)</span><br><span class="line">2.220446049250313e-16</span><br><span class="line"></span><br><span class="line">julia&gt; eps() <span class="comment"># same as eps(Float64)</span></span><br><span class="line">2.220446049250313e-16</span><br></pre></td></tr></table></figure>
<p>这些数值是 <code>2.0^-23</code> 和 <code>2.0^-52</code> 分别作为 <code>Float32</code> 值和 <code>Float64</code> 值。<code>eps</code> 函数也可以代入一个浮点值作为参数并给出在这个值和下一个可表示的值之间的的绝对差异。是的， <code>eps(x)</code> 产生了一个和 <code>x</code> 同类型的值，以至于 <code>x + eps(x)</code> 就是下一个稍大于 <code>x</code> 的可表示出的浮点数值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; eps(1.0)</span><br><span class="line">2.220446049250313e-16</span><br><span class="line"></span><br><span class="line">julia&gt; eps(1000.)</span><br><span class="line">1.1368683772161603e-13</span><br><span class="line"></span><br><span class="line">julia&gt; eps(1e-27)</span><br><span class="line">1.793662034335766e-43</span><br><span class="line"></span><br><span class="line">julia&gt; eps(0.0)</span><br><span class="line">5.0e-324</span><br></pre></td></tr></table></figure>
<p>&emsp;两个相邻的浮点数之间的距离并不是固定的，但是数值越大距离越大，数值越小距离旧越小。 换句话说在接近于0的实数线上可表示的浮点数是密集的，并且距离 <code>0</code> 以指数方式越远旧越稀疏。 作为规范 <code>eps(1.0)</code> 等于 <code>eps(Float64)</code> 因为 <code>1.0</code> 是 64 位的浮点数值。</p>
<p>Julia 同样分别为返回最小和最大的可表示浮点数提供了 <code>nextfloat</code> 和 <code>prevfloat</code> 函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = 1.25f0</span><br><span class="line">1.25f0</span><br><span class="line"></span><br><span class="line">julia&gt; nextfloat(x)</span><br><span class="line">1.2500001f0</span><br><span class="line"></span><br><span class="line">julia&gt; prevfloat(x)</span><br><span class="line">1.2499999f0</span><br><span class="line"></span><br><span class="line">julia&gt; bitstring(prevfloat(x))</span><br><span class="line"><span class="string">"00111111100111111111111111111111"</span></span><br><span class="line"></span><br><span class="line">julia&gt; bitstring(x)</span><br><span class="line"><span class="string">"00111111101000000000000000000000"</span></span><br><span class="line"></span><br><span class="line">julia&gt; bitstring(nextfloat(x))</span><br><span class="line"><span class="string">"00111111101000000000000000000001"</span></span><br></pre></td></tr></table></figure>
<p>这个例子强调了相邻的可表示浮点数值也有相邻的可表示的二进制整数表示的通用原理。</p>
<h4 id="舍入模式"><a href="#舍入模式" class="headerlink" title="舍入模式"></a>舍入模式</h4><p>&emsp;如果一个数字没有一个明确的浮点表示，那么它旧必须被舍入到一个合适的可表示的值。不过，需要舍入的其方式是按照 <code>IEEE 754</code> 的标准舍入模式完成的。</p>
<p>默认使用的模式总是舍入到最近的可表示值，通常使用连结舍入到最近的至少一个重要的位的值的最近舍入模式。</p>
<h4 id="背景和参考"><a href="#背景和参考" class="headerlink" title="背景和参考"></a>背景和参考</h4><p>&emsp;浮点计算牵扯到很多会让不熟悉的低级实现细节的用户惊讶的细微差别。不过这些细微的差别在多数科学计算书籍中都有描写，下列的参考中也有这些内容：</p>
<ul>
<li>浮点计算的最终指为 <code>IEEE 754-2008</code> 标准，但是在网上并不是免费可用的。</li>
<li>对于浮点数如何表示的简单但清晰的表述，可以查看 <code>John D. Cook</code> 在课题上也同样是他对从此种表述行为于来自于实数的理想抽象化不同方面引发的问题的概述上的文章。</li>
<li>同样推荐的是 <code>Bruce Dawson</code> 关于浮点数的一系列博文。</li>
<li>为了更好地深入地讨论浮点数和在使用浮点计算时遇到的数字精度问题，可以查看 <code>David Goldberg</code> 的《每个计算机科学从业者都需要了解的浮点计算》论文。</li>
<li>对于广阔的有关于浮点数的历史、基本理论和问题，以及其他数字计算主题中的讨论，查看 <code>William Kahan</code> 整理的著作，常称之为 ”浮点数之父“。 特别感兴趣的可能是对浮点数老前辈的访谈。</li>
</ul>
<h3 id="高精度计算"><a href="#高精度计算" class="headerlink" title="高精度计算"></a>高精度计算</h3><p>&emsp;为了能使用高精度整数和浮点数计算，Julia 分别封装了<code>多精度计算库通用授权库 (GNU Multiple Precision Arithmetic Library (GMP))</code> 和 <code>多精度浮点计算通用授权库（GNU MPFR）</code>。Julia 中同样也可以分别为高精度的整数和浮点数计算使用 <code>BigInt</code> 和 <code>BigFloat</code> 类型。</p>
<p>&emsp;这些类型基础数字类型中的构造器可以创建这些类型，并且可以使用 <code>解析 （parse）</code>从 <code>AbstractStrings</code> 中构造。这个类型一旦被创建，他们就可以像其他数字类型一样参与计算，感谢 Julia 的类型提升和转换机制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; BigInt(typemax(Int64)) + 1</span><br><span class="line">9223372036854775808</span><br><span class="line"></span><br><span class="line">julia&gt; parse(BigInt, <span class="string">"123456789012345678901234567890"</span>) + 1</span><br><span class="line">123456789012345678901234567891</span><br><span class="line"></span><br><span class="line">julia&gt; parse(BigFloat, <span class="string">"1.23456789012345678901"</span>)</span><br><span class="line">1.234567890123456789010000000000000000000000000000000000000000000000000000000004</span><br><span class="line"></span><br><span class="line">julia&gt; BigFloat(2.0^66) / 3</span><br><span class="line">2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19</span><br><span class="line"></span><br><span class="line">julia&gt; factorial(BigInt(40))</span><br><span class="line">815915283247897734345611269596115894272000000000</span><br></pre></td></tr></table></figure>
<p>但是在以上的基本类型和 <code>BigInt/Bigfloat</code> 中的提升并不是自动的，必须显式地阐明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = typemin(Int64)</span><br><span class="line">-9223372036854775808</span><br><span class="line"></span><br><span class="line">julia&gt; x = x - 1</span><br><span class="line">9223372036854775807</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(x)</span><br><span class="line">Int64</span><br><span class="line"></span><br><span class="line">julia&gt; y = BigInt(typemin(Int64))</span><br><span class="line">-9223372036854775808</span><br><span class="line"></span><br><span class="line">julia&gt; y = y - 1</span><br><span class="line">-9223372036854775809</span><br><span class="line"></span><br><span class="line">julia&gt; typeof(y)</span><br><span class="line">BigInt</span><br></pre></td></tr></table></figure>
<p>&emsp;<code>BigFloat</code> 的默认精度和舍入模式可以通过调用 <code>setprecison</code> 和 <code>setrounding</code> 进行全局更改，所有更进一步的计算都将使用这些改变进行。不然精度或舍入只能在 <code>do</code> 代码块中执行特定的代码块改变：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; setrounding(BigFloat, RoundUp) <span class="keyword">do</span></span><br><span class="line">           BigFloat(1) + parse(BigFloat, <span class="string">"0.1"</span>)</span><br><span class="line">       end</span><br><span class="line">1.100000000000000000000000000000000000000000000000000000000000000000000000000003</span><br><span class="line"></span><br><span class="line">julia&gt; setrounding(BigFloat, RoundDown) <span class="keyword">do</span></span><br><span class="line">           BigFloat(1) + parse(BigFloat, <span class="string">"0.1"</span>)</span><br><span class="line">       end</span><br><span class="line">1.099999999999999999999999999999999999999999999999999999999999999999999999999986</span><br><span class="line"></span><br><span class="line">julia&gt; setprecision(40) <span class="keyword">do</span></span><br><span class="line">           BigFloat(1) + parse(BigFloat, <span class="string">"0.1"</span>)</span><br><span class="line">       end</span><br><span class="line">1.1000000000004</span><br></pre></td></tr></table></figure>
<h3 id="数字字符系数"><a href="#数字字符系数" class="headerlink" title="数字字符系数"></a>数字字符系数</h3><p>&emsp;为了让一般的数字方程和表达式更清晰，Julia 允许在变量前直接使用意指相乘的数字字符。这让书写多项式变得清晰很多：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = 3</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">julia&gt; 2x^2 - 3x + 1</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">julia&gt; 1.5x^2 - .5x + 1</span><br><span class="line">13.0</span><br><span class="line">It also makes writing exponential <span class="built_in">functions</span> more elegant:</span><br><span class="line"></span><br><span class="line">julia&gt; 2^2x</span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<p>The precedence of numeric literal coefficients is slightly lower than that of unary operators such as negation. So -2x is parsed as (-2) <em> x and √2x is parsed as (√2) </em> x. However, numeric literal coefficients parse similarly to unary operators when combined with exponentiation. For example 2^3x is parsed as 2^(3x), and 2x^3 is parsed as 2*(x^3).</p>
<p>Numeric literals also work as coefficients to parenthesized expressions:</p>
<p>julia&gt; 2(x-1)^2 - 3(x-1) + 1<br>3<br>Note<br>The precedence of numeric literal coefficients used for implicit multiplication is higher than other binary operators such as multiplication (*), and division (/, \, and //). This means, for example, that 1 / 2im equals -0.5im and 6 // 2(2 + 1) equals 1 // 1.</p>
<p>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:</p>
<p>julia&gt; (x-1)x<br>6<br>Neither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized expression, however, can be used to imply multiplication:</p>
<p>julia&gt; (x-1)(x+1)<br>ERROR: MethodError: objects of type Int64 are not callable</p>
<p>julia&gt; x(x+1)<br>ERROR: MethodError: objects of type Int64 are not callable<br>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see Functions for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</p>
<p>The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies.</p>
<p>Syntax Conflicts<br>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:</p>
<p>The hexadecimal integer literal expression 0xff could be interpreted as the numeric literal 0 multiplied by the variable xff.<br>The floating-point literal expression 1e10 could be interpreted as the numeric literal 1 multiplied by the variable e10, and similarly with the equivalent E form.<br>The 32-bit floating-point literal expression 1.5f22 could be interpreted as the numeric literal 1.5 multiplied by the variable f22.<br>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</p>
<p>Expressions starting with 0x are always hexadecimal literals.<br>Expressions starting with a numeric literal followed by e or E are always floating-point literals.<br>Expressions starting with a numeric literal followed by f are always 32-bit floating-point literals.<br>Unlike E, which is equivalent to e in numeric literals for historical reasons, F is just another letter and does not behave like f in numeric literals. Hence, expressions starting with a numeric literal followed by F are interpreted as the numerical literal multiplied by a variable, which means that, for example, 1.5F22 is equal to 1.5 * F22.</p>
<p>Literal zero and one<br>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.</p>
<p>Function    Description<br>zero(x)    Literal zero of type x or type of variable x<br>one(x)    Literal one of type x or type of variable x<br>These functions are useful in Numeric Comparisons to avoid overhead from unnecessary type conversion.</p>
<p>Examples:</p>
<p>julia&gt; zero(Float32)<br>0.0f0</p>
<p>julia&gt; zero(1.0)<br>0.0</p>
<p>julia&gt; one(Int32)<br>1</p>
<p>julia&gt; one(BigFloat)<br>1.0</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.thgd.net/2019/02/28/GettingStart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="醍醐果冻">
      <meta itemprop="description" content="AI,人工智能,Julia中文文档，Julia编程语言">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醍醐果冻">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/GettingStart/" class="post-title-link" itemprop="url">入门</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-28 09:13:43" itemprop="dateCreated datePublished" datetime="2019-02-28T09:13:43+08:00">2019-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-04 10:47:06" itemprop="dateModified" datetime="2019-03-04T10:47:06+08:00">2019-03-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/" itemprop="url" rel="index"><span itemprop="name">Julia中文文档</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/手册/" itemprop="url" rel="index"><span itemprop="name">手册</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/手册/入门/" itemprop="url" rel="index"><span itemprop="name">入门</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;无论使用从源代码的预编译二进制文件还是编译文件，Julia的安装都简单直接。可以在 <a href="https://julialang.org/downloads/" target="_blank" rel="noopener">https://julialang.org/downloads/</a> 按照指引下载和安装Julia。<br>&emsp;学习和体验Julia最简单的方式就是双击Julia的可执行程序或从命令行来启动Julia以开始一个可交互会话（也叫做 读取-求值-输出 循环 或简称为 <code>“REPL”</code>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ julia</span><br><span class="line"></span><br><span class="line">               _</span><br><span class="line">   _       _ _(_)_     |  Documentation: https://docs.julialang.org</span><br><span class="line">  (_)     | (_) (_)    |</span><br><span class="line">   _ _   _| |_  __ _   |  Type <span class="string">"?"</span> <span class="keyword">for</span> <span class="built_in">help</span>, <span class="string">"]?"</span> <span class="keyword">for</span> Pkg <span class="built_in">help</span>.</span><br><span class="line">  | | | | | | |/ _` |  |</span><br><span class="line">  | | |_| | | | (_| |  |  Version 1.1.0 (2019-01-21)</span><br><span class="line"> _/ |\__<span class="string">'_|_|_|\__'</span>_|  |  </span><br><span class="line">|__/                   |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">julia&gt; 1 + 2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">julia&gt; ans</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>&emsp;输入CTRL-D(同时按下 ctrl 和 d 键)或输入<code>exit()</code>退出交互会话。当Julia运行在交互模式时会显示标题提示用户输入。一旦用户输入了一个完整的表达式，比如 1+2，并且敲击 enter 键， 交互会话会计算表达式并显示出它的值。如果在交互会话中的表达式以分号结尾，将不会显示它的值。无论值显示与否变量 ans 的值都是最后计算的表达式的结果。这个变量只能存在于交互会话中，Julia代码在其他方式运行时不存在。</p>
<p>要计算在资源文件 <code>file.jl</code> 中的表达式，输入 <code>include(&quot;file.jl&quot;)</code></p>
<p>要在文件中无交互性地运行代码，你可以把它作为首个参数传递给 Julia 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ julia script.jl arg1 arg2...</span><br></pre></td></tr></table></figure>
<p>&emsp;如示例代码所示，下列传递给Julia命令行代码参数被翻译为程序 <code>script.jl</code> 的命令行参数, 传入全局常量 <code>ARGS</code>。 脚本本身的名称作为全局<br><code>PROGRAM_FILE</code>传入。 注意当 Julia 表达式在命令行中使用 <code>-e</code> 选项时 <code>ARGS</code> 也被设置（查看下方 Julia 输出的帮助） 但是 <code>PROGRAM_FILE</code> 将会为空。例如仅打印出传递给脚本的参数，您可以这么做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ julia -e <span class="string">'println(PROGRAM_FILE); for x in ARGS; println(x); end'</span> foo bar</span><br><span class="line"></span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>或者你可以把代码放入脚本中并且执行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'println(PROGRAM_FILE); for x in ARGS; println(x); end'</span> &gt; script.jl</span><br><span class="line">$ julia script.jl foo bar</span><br><span class="line">script.jl</span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p><code>-- delimiter</code> 可以专门用来拆分来自专用于Julia的参数的脚本文件命令行参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ julia --color=yes -O -- foo.jl arg1 arg2..</span><br></pre></td></tr></table></figure>
<p>在 <a href="https://docs.julialang.org/en/v1/manual/faq/#man-scripting-1" target="_blank" rel="noopener">脚本</a> 上查看编写Julia脚本的更多信息。</p>
<p>&emsp;Julia可以通过 <code>-p</code> 或者 <code>--machine-file</code> 选项在平行模式中启动。 <code>-p n</code> 将会载入一个额外的 <code>n</code> 工作进程， 同时 <code>--machine-file</code> 文件将会为每一个文件中的行在归档的文件中载入一个工作。 在机器中定义的文件必须可以通过无密码的 <code>ssh</code> 登陆，并且Julia和当前的主机安装在同一个位置。每个机器定义带有格式 <code>[count*][user@]host[:port][bind_addr[:port]]</code>。 用户为默认用户，端口为标准 ssh 端口。数量为节点产生的工作数，默认为1。 可选的 <code>bind-to bind_addr[:port]</code> 定义了用于连接到此工作项的工作项的端口和IP地址。</p>
<p>如果您希望您的代码在当Julia启动时执行，您可以把它放到<code>~/.julia/config/startup.jl</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'println("Greetings! 你好! 안녕하세요?")'</span> &gt; ~/.julia/config/startup.jl</span><br><span class="line">$ julia</span><br><span class="line">Greetings! 你好! 안녕하세요?</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>有多种多样的方式去执行Julia代码并提供选项，类似于这些用于 perl 和 ruby 程序里的：</p>
<p><code>·julia [switches] -- [programfile] [args...]</code></p>
<table>
<thead>
<tr>
<th>选项切换</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v, –version</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-h, –help</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td>–project[={<dir> &#166; @.}]</dir></td>
<td>设置 <code>&lt;dir&gt;</code> 为项目或环境的主页。默认的<code>@.</code>选项将会搜索父级目录直到找到<code>Project.toml</code>或者<code>JuliaProject.toml</code>文件</td>
</tr>
<tr>
<td>-J, –sysimage <file></file></td>
<td>以给定的系统图片文件启动</td>
</tr>
<tr>
<td>-H, –home <dir></dir></td>
<td>设置Julia的可执行位置</td>
</tr>
<tr>
<td>–startup-file={yes&brvbar;no}</td>
<td>加载 <code>~/.julia/config/startup.jl</code></td>
</tr>
<tr>
<td>–handle-signals={yes&brvbar;no}</td>
<td>启用或关闭Julia的信号控制器</td>
</tr>
<tr>
<td>–sysimage-native-code={yes&brvbar;no}</td>
<td>如果可用则使用系统镜像里的本地代码</td>
</tr>
<tr>
<td>–compiled-modules={yes&brvbar;no}</td>
<td>启用或关闭模块的增加预编译</td>
</tr>
<tr>
<td>-e, –eval <expr></expr></td>
<td>求值 <code>&lt;expr&gt;</code></td>
</tr>
<tr>
<td>-E, –print <expr></expr></td>
<td>求 <code>&lt;expr&gt;</code> 的值并显示结果</td>
</tr>
<tr>
<td>-L, –load <file></file></td>
<td>立即在所有进程上加载 <code>&lt;file&gt;</code></td>
</tr>
<tr>
<td>-p, –procs {N&brvbar;auto}</td>
<td>整数值 N 开始 N 个额外的本地工作进程；自动开始和本地CPU线程一样多的工作数（逻辑核心）</td>
</tr>
<tr>
<td>–machine-file <file></file></td>
<td>在主机上运行列于<code>&lt;file&gt;</code>的进程</td>
</tr>
<tr>
<td>-i</td>
<td>交互模式；REPL 运行并且 <code>isinteractive()</code> 置为 <code>true</code></td>
</tr>
<tr>
<td>-q, –quiet</td>
<td>静默启动：没有大标题，封滞REPL警告</td>
</tr>
<tr>
<td>–banner={yes&brvbar;no&brvbar;auto}</td>
<td>启用或关闭启动大标题</td>
</tr>
<tr>
<td>–color={yes&brvbar;no&brvbar;auto}</td>
<td>启用或关闭彩色文本</td>
</tr>
<tr>
<td>–history-file={yes&brvbar;no}</td>
<td>加载或保存历史</td>
</tr>
<tr>
<td>–depwarn={yes&brvbar;no&brvbar;error}</td>
<td>启用或关闭语法和方法否决警告（错误变成警告到错误中）</td>
</tr>
<tr>
<td>–warn-overwrite={yes&brvbar;no}</td>
<td>启用或关闭方法重写警告</td>
</tr>
<tr>
<td>-C, –cpu-target <target></target></td>
<td>限制CPU特性使用直到<code>&lt;target&gt;</code>；调到帮助以查看可用选项</td>
</tr>
<tr>
<td>-O, –optimize={0,1,2,3}</td>
<td>设置优化级别（如果未定义默认级别是2，如果不按级别使用则默认级别为3）</td>
</tr>
<tr>
<td>-g, -g <level></level></td>
<td>启用/设置 调试信息的创建级别（如果未定义则默认级别为1，如果不按基本使用则默认级别为2）</td>
</tr>
<tr>
<td>–inline={yes&brvbar;no}</td>
<td>控制是否允许 <code>inling</code>，包括重写 <code>@inlie</code> 声明</td>
</tr>
<tr>
<td>–check-bounds={yes&brvbar;no}</td>
<td>限制总是或从不进行边界检查（除声明时）</td>
</tr>
<tr>
<td>–math-mode={ieee,fast}</td>
<td>不允许或启用不安全浮点优化（重写 <code>@fastmath</code> 声明）</td>
</tr>
<tr>
<td>–code-coverage={none&brvbar;user&brvbar;all}</td>
<td>执行资源行的总数计算</td>
</tr>
<tr>
<td>–code-coverage</td>
<td>等同于 <code>--code-coverage=user</code></td>
</tr>
<tr>
<td>–track-allocation={none&brvbar;user&brvbar;all}</td>
<td>通过每个资源行计算字节分配总数</td>
</tr>
<tr>
<td><code>--track-allocation</code></td>
<td>同<code>--track-allocation=user</code></td>
</tr>
</tbody>
</table>
<p>Julia 1.1<br>&emsp;在Julia 1.0，默认的 <code>--project=@.</code> 选项不再从 <code>Project.toml</code> 文件Git仓库的根目录搜索。但从 Julia 1.1 版本开始则会搜索。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>&emsp;可以在Julia的主网站的<a href="https://julialang.org/learning/" target="_blank" rel="noopener">学习</a> 页面找到精选后帮助新用户入门的实用资源列表。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.thgd.net/2019/02/27/Julia-v1-1-更新日志/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="醍醐果冻">
      <meta itemprop="description" content="AI,人工智能,Julia中文文档，Julia编程语言">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醍醐果冻">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/27/Julia-v1-1-更新日志/" class="post-title-link" itemprop="url">Julia v1.1 更新日志</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-27 09:27:08" itemprop="dateCreated datePublished" datetime="2019-02-27T09:27:08+08:00">2019-02-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-28 17:39:28" itemprop="dateModified" datetime="2019-02-28T17:39:28+08:00">2019-02-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/" itemprop="url" rel="index"><span itemprop="name">Julia中文文档</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/Julia-v1-1-更新日志/" itemprop="url" rel="index"><span itemprop="name">Julia v1.1 更新日志</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="新的语言特性"><a href="#新的语言特性" class="headerlink" title="新的语言特性"></a>新的语言特性</h2><ul>
<li>一个异常栈被修复以让每个异常控制更加的强壮并且开启根原因分析。这个栈可能在使用试验性函数 Base.catch_stack时存取（#28878）</li>
<li>试验性宏命令Base.@locals返回当前的本地变量名和值字典（#29733）</li>
<li>二元~现在可以被加点了，像是在 x .~ y（#30341）</li>
</ul>
<h2 id="语言变化"><a href="#语言变化" class="headerlink" title="语言变化"></a>语言变化</h2><ul>
<li>解析器现在将输入以逗号结尾的情况统一认定为未完成。之前取决于空格他们有时被解析为数组（#28506）。</li>
<li>广播调用语法，e.g.f. (x)中允许意外空格。现在不再允许，统一被认定为正常函数调用语法（#29781）。</li>
<li>大整数字符和命令语法（反引号）现在被格式化为宏命令的名字（@int128_str,@uint128_str,@big_str,@cmd）以合格地适用于核心模块（#29968）。</li>
<li>本地变量和静态参数使用同一名称将为是一个错误而不是警告（#29429）。</li>
<li>为了findall方法的一致性，当a是一个矩阵或一个较高维的数组时，findall(in(b),a)现在返回一个CartesianIndex。使用LinearIndices(a)[findall(in(b),a)]获得旧的行为，或者在Julia的早期版本中使用CartesianIndices(a)[findall(in(b),a)]获得新行为（#30226）。</li>
<li>为了其他数组类型的一致性，当a是一个矩阵或者较高维的数组时findmin（::BitArray）和 findmax（::BitArray）现在返回一个CartesianIndex。使用LinearIndices(a)[findmin(a)[2]]以获得旧行为，或者在早期版本的Julia中使用CartesianIndices(a)[findmin(a)[2]]以获得新的行为。</li>
<li>类似f(::Type{T},::T) where {T &lt;: X} and f(::Type{X}, ::Any)现在都被认为是混淆的。早期的一个故障导致第一个在某些情况下被看作更加明确（#30160）。</li>
</ul>
<h2 id="命令行选项变化"><a href="#命令行选项变化" class="headerlink" title="命令行选项变化"></a>命令行选项变化</h2><ul>
<li>当脚本运行在交互模式（-i）时会抛出一个异常，在异常被抛出后REPL才开始启动。在先前REPL仅在脚本无错误完全开始后才启动（#21233）。</li>
<li>代码覆盖选项现在支持在LCOV跟踪文件格式并且传播到子进程，比如预编译步骤和测试器（#30381）。</li>
</ul>
<h2 id="新的库函数"><a href="#新的库函数" class="headerlink" title="新的库函数"></a>新的库函数</h2><ul>
<li>splitpath(p::String)函数，是joinpath(parts…)反函数：它分割一个文件路径进入它的组件中（#28156）。</li>
<li>isnothing(::Any)判定语句，用于检查参数的有无。（#29679）</li>
<li>getpid(::Process)方法(#24064)。</li>
<li>eachrow,eachcol和eachslice函数在数组段上提供了高效的迭代器（#29749）。</li>
<li>fieldtypes(T::Type)返回在类型T中的字段的类型。</li>
<li>uuid5 现在被添加到了UUIDs的标准库（#28761）。</li>
<li>添加了为检测BSD系统的判断语句Sys.isfreebsd,Sys.isopenbsd,Sys.isnetbsd,and Sys.isdragonfly（#30249）。</li>
<li>内部的Base.disable_library_threading 设置库去使用一个线程。它执行用Base.at_disable_library_threading注册的函数钩子（#30004）。</li>
</ul>
<h2 id="标准库变化"><a href="#标准库变化" class="headerlink" title="标准库变化"></a>标准库变化</h2><ul>
<li>CartesianIndices现在可以从两个CartesianIndexes I and I:J进行构造（#29440）。</li>
<li>CartesianIndices支持使用一个CartesianIndex的广播算法（ + 和 - ）（#29890）。</li>
<li>支持数组、字典和集合的copy!现在从Future包被移动到Base（#29173）。<ul>
<li>频道现在替代了需要类型去匹配而转换进值里（类似于容器）（#29092）。</li>
<li>range 可以接受一个停止值作为位置参数，例如range(1,10,step=2)（#28708）。</li>
<li>diff 现在支持任意维度的数组，并且支持在任何唯独上进行计算（#29827）。</li>
<li>构造器BigFloat(::BigFloat)现在遵守全局精度设置并且总是返回一个和precision(BigFloat)一样精度的BigFloat（#29127）。可选的可以重写全局设置的precision参数现在被从固定参数替代为关键字。（#29157）</li>
<li>在输出BigFloat类型的值时科学符号现在被和其他浮点类型一直看待（#29211）。</li>
<li>Regex在广播中使用时的行为像似一个纯量（#29913）。</li>
<li>Char的行为现在如同一个只读的0维数组（#29819）。</li>
<li>对于Bool类型parse现在允许字符串类型代替整数类型0和1（#29980）。</li>
<li>Base.tail现在可以在已命名的元组中工作了（#29595）。</li>
<li>为了跟踪多进程的内容分配，进程id被追加到内存分配日志文件中（#29969）。</li>
<li>Base.julia_cmd 现在可以传递 –-inline=(yes|no)标识（#29858）。</li>
<li>Base.@kwdef现在可以被用于参数结构和用超级类型的结构（#29316）。</li>
<li>merge(::NamedTuple,::NamedTuple)现在可以和多于2个的NamedTuples（#29259）使用。</li>
<li>新的ncodeunits(c::Char)方法等于一个快速的ncodeunits(string(c))（#29153）。</li>
<li>新的sort!(::AbstractArray;dims)方法现在可以按照dims维度排序数组（#28902）。</li>
<li>get(A::AbstractArray, (), default) 现在返回A[]而不是空数组()(#30270)。</li>
<li>现在支持parse(Bool, str) (#29997)。</li>
<li>copyto!(::AbstractMatrix, ::UniformScaling) 现在支持正则矩阵(#28790)。</li>
<li>current_project() 现在搜索Git仓库的父级目录以查找Project.toml文件。这同样影响使用默认 --project=@时的 –project 命令行选项（#29108）。</li>
<li>spwan API现在更加灵活地直接把IOBuffer作为I/O流获取，如果需要则会转换为系统管线（#30278）。</li>
</ul>
</li>
</ul>
<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><ul>
<li>新的DateTime(::Date,::Time)构造器（#29754）。</li>
<li>TimeZone的在用作广播时的行为近似于一个数量（#30159）。</li>
</ul>
<h3 id="可交互实用工具"><a href="#可交互实用工具" class="headerlink" title="可交互实用工具"></a>可交互实用工具</h3><ul>
<li>edit现在可以被在已定义的文件的模块中调用（#29636）。</li>
<li>所有的编译器镜像工具（例如函数和宏命令的code_class）现在以一般风格输出精确的线性数字和内联信息，并且给一个可选参数(debuginfo=:default)来控制元数据的显示(#29893)。 </li>
</ul>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><ul>
<li>调式和缩放比例 isdiag 和 isposdef (#29638)。</li>
<li>缩放比例 nul!、rmull!和lmul! 方法 (#29506)。</li>
<li>斜对称和埃尔米特矩阵现在在当以数字增大时保持包装(#29469)。</li>
<li>求幂运算符 ^ 现在支持提升无理数到抽象矩阵的能力（#29782）。</li>
<li>添加了关键字参数 rtol、rtol 到 pinv、nullspace 和 rank (#29998, #29926)。</li>
</ul>
<h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><ul>
<li>randperm 和 randcycle 现在使用他们的参数类型确定返回数组的元素类型(#29670)。</li>
<li>一个新方法 rand(::Tuple) 实现了来自元组的值的样本(#25278)。</li>
<li>serialize 和 deserialize 现在和 write 、read 一样接受一个文件名参数(#30151)。</li>
</ul>
<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><ul>
<li>sprandn 现在支持指定输出元素类型（#30083）。</li>
</ul>
<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><ul>
<li>mean 和 var 现在可以控制更多类型的空输入（#29003）。</li>
</ul>
<h2 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h2><ul>
<li>7zip（在windows上和Julia捆绑）从版本16.04升级到了18.05（#30035）。</li>
<li>Busybox 不再与Windows上的Julia捆绑（#30022）。</li>
<li>OpenBLAS 从0.3.2 升级到 0.3.3（#29845）。</li>
<li>Pkg的源代码不再包含进JuliaLang/julia. Pkg 在编译过程被被替换下载（#29615）。</li>
<li>LLVM升级到了6.0.1并且减少到支持小于6.0版本(#28745, #28696)。</li>
<li>Pkg 升级到1.1版（#30342）。</li>
</ul>
<h2 id="替代或移除"><a href="#替代或移除" class="headerlink" title="替代或移除"></a>替代或移除</h2><ul>
<li>one(i::CartesianIndex) 被替换为 oneunit(i::CartesianIndex)(#29442)。</li>
<li>内部数组 Base.Grisu.DIGITS 被替代; 新代码需要使用 Base.Grisu.getbuf() 以获得一个合适的 task-local 缓存，并代替而用它传递给 grisu()。</li>
<li>移除了内部函数 Base._default_type(T)。它的调用应该只被替换为参数T(#29739)。</li>
<li>peakflops 被计划从 InteractiveUtils 移动到 LinearAlgebra, 但它现在已经可以在 LinearAlgebra.peakflops 可用(#29978)。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.thgd.net/2019/02/26/概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="醍醐果冻">
      <meta itemprop="description" content="AI,人工智能,Julia中文文档，Julia编程语言">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="醍醐果冻">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/26/概述/" class="post-title-link" itemprop="url">概述</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-26 16:52:45" itemprop="dateCreated datePublished" datetime="2019-02-26T16:52:45+08:00">2019-02-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-01 17:52:14" itemprop="dateModified" datetime="2019-03-01T17:52:14+08:00">2019-03-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/" itemprop="url" rel="index"><span itemprop="name">Julia中文文档</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Julia中文文档/概述/" itemprop="url" rel="index"><span itemprop="name">概述</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;科学计算有着对最高性能的传统需求，然而该领域的专家们大部分都使用较慢的动态编程语言用于日常工作。我们相信这些应用程序有很多偏爱使用动态编程语言益处和原因，我们也不是期望他们能少一些使用这些语言。幸运的是，现代的程序语言设计和编译器技术让在足够产品化的原型设计和足够高效的部署性能敏感的应用程序最大限度地平衡性能并提供一个单一的环境成为可能。Julia程序语言填补了这项空白：它是一个自由的动态语言，适用于科学和数字计算，而性能上则接近于传统的静态类型语言。</p>
<p>&emsp;由于 Julia 的编译器与用于 Python 和 R 语言的翻译器不同，一开始您可能不是那么地直观地体会到Julia的性能。如果您发现有些代码会有些慢，我们强烈推荐您在尝试编写代码之前先阅读<a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-tips-1" target="_blank" rel="noopener">性能建议</a>部分。一旦您理解了 Julia 的工作方式，它将会很容易地编写像 C 语言一样快的代码。</p>
<p>&emsp;Julia 以可选类型、多重分派和高性能为特点，利用类型接口和<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener">即时编译</a>，利用 <a href="https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine" target="_blank" rel="noopener">LLVM</a> 进行具体实现。它是一个多范例的，结合了命令和函数，面向对象的编程语言。Julia 为高级的数字计算提供了如 R、MATLAB 和 Python 同样的舒适度和表现力，并且同样支持普通编程。要达到这点，Julia 继承了数学程序语言的血统，同样地从包括Lisp、Perl、Python、Lua和Ruby这些流行的动态程序语言中借用了很多特点。</p>
<p> Julia与典型的动态语言最重要的区别是：</p>
<ul>
<li>核心语言实现非常地小巧；Julia 的基础和标准库由Julia自身编写，包含了如整数算法的基础运算</li>
<li>为结构和订阅对象提供的一个富类型语言，这同样可以有选择性地进行类型声明</li>
<li>通过多重分派来定义跨参数类型组合的函数行为的能力</li>
<li>为不同的参数类型创建高效、专用的代码</li>
<li>良好的性能，接近于类似 C 这样的静态编译的语言</li>
</ul>
<p>&emsp;尽管有些时候动态语言说是”无类型的”，他们实际上却不是：每一个无论是否是用户定义的对象都有一个类型。然而多数动态语言类型声明的缺陷指的是不能让编译器推断出值的类型，且通常也不能够涉及到类型。另一方面，在尽管有些静态语言可以推断，但是通常必须为编译器注释出类型，类型只存在于编译时并且不能在运行时进行修改或者展现。在 Julia 中，类型是运行时对象自身，并且同样可以用来给编译器传递信息。</p>
<p>&emsp;虽然非职业的程序员不必显式地使用类型或者多重分派，他们都是 Juliau 一致的核心特性：函数都是定义在不同的参数类型组合中并且通过分派到最明确匹配的定义来进行分配。这个模型对于数学编程很合适，但对于传统面向对象的分派中首个参数去 “拥有” 一个运算来说却是反常的。运算符仅仅是有着特殊标识符的函数 ，<code>“-”</code>用来扩展附加到新的用户定义数据类型，并为 <code>“+”</code> 函数定义新的方法。然后已经存在的代码无缝地分配到这些新的数据类型。</p>
<p>&emsp;部分由于运行时类型接口（由可选类型注释增加），部分则由于从项目的初始就强烈地关注性能，Julia的计算效率超过了其他的动态语言，甚至等同于静态编译的语言。对于大规模的数字程序，速度一直并且将会一直并且总是重要的：在过去的几十年里，计算过的数据量一直轻松地在摩尔定律上保持着增长。</p>
<p>Julia开拓性以的在一个单独的语言中将易用性、强大并且高效率结合为目标。除上述之外，相比于其他类似的系统，Julia的优势还包括：</p>
<ul>
<li>免费并且开源（MIT licensed）</li>
<li>用户定义类型和内置类型一样的快速和紧凑</li>
<li>无需为性能而去矢量化代码；非矢量代码一样快</li>
<li>为平行计算和分布式计算设计</li>
<li>轻量化“绿色”线程（协同程序）</li>
<li>低调但强大的类型系统</li>
<li>优雅并且可扩展的数字和其他类型的转换和优化</li>
<li>高效率持支Unicode,包括但不限于UTF-8</li>
<li>直接调用 C 语言函数（无需包装或者专用API）</li>
<li>强大的贝壳型进程管理能力</li>
<li>类 Lisp 的宏指令和其他语言的元程序设施</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">醍醐果冻</p>
              <p class="site-description motion-element" itemprop="description">AI,人工智能,Julia中文文档，Julia编程语言</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">文章</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <a href="http://www.miitbeian.gov.cn" rel="noopener" target="_blank"> </a>&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">醍醐果冻</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
      <div>
        <div class="addthis_inline_share_toolbox">
  <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5c7ccddf6491bf4c" async="async"></script>
</div>

      </div>
    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





  



  






  







  
  







  



  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script src="/lib/three/three.min.js"></script>

  
  <script src="/lib/three/canvas_lines.min.js"></script>

  
  <script src="/lib/reading_progress/reading_progress.js"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  



  




  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      
        background-color: #eee;
        background-image: linear-gradient(#fcfcfc, #eee);
        border: 1px solid #d5d5d5;
        border-radius: 3px;
      
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      
        right: 4px;
        top: 8px;
      
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1;
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; // Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.readOnly = true;
        ta.value = code;
        document.body.appendChild(ta);
        ta.select();
        ta.setSelectionRange(0, code.length);
        ta.readOnly = false;
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); // For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


</body>
</html>
